{"version":3,"file":"utils.mjs","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { KeyringObject } from '@metamask/keyring-controller';\nimport { KeyringTypes } from '@metamask/keyring-controller';\nimport type { InternalAccount } from '@metamask/keyring-internal-api';\nimport type { Infer } from '@metamask/superstruct';\nimport { is, number, string, type } from '@metamask/superstruct';\nimport { hexToBytes } from '@metamask/utils';\nimport { sha256 } from 'ethereum-cryptography/sha256';\nimport type { V4Options } from 'uuid';\nimport { v4 as uuid } from 'uuid';\n\n/**\n * Returns the name of the keyring type.\n *\n * @param keyringType - The type of the keyring.\n * @returns The name of the keyring type.\n */\nexport function keyringTypeToName(keyringType: string): string {\n  switch (keyringType) {\n    case KeyringTypes.simple: {\n      return 'Account';\n    }\n    case KeyringTypes.hd: {\n      return 'Account';\n    }\n    case KeyringTypes.trezor: {\n      return 'Trezor';\n    }\n    case KeyringTypes.oneKey: {\n      return 'OneKey';\n    }\n    case KeyringTypes.ledger: {\n      return 'Ledger';\n    }\n    case KeyringTypes.lattice: {\n      return 'Lattice';\n    }\n    case KeyringTypes.qr: {\n      return 'QR';\n    }\n    case KeyringTypes.snap: {\n      return 'Snap Account';\n    }\n    default: {\n      throw new Error(`Unknown keyring ${keyringType}`);\n    }\n  }\n}\n\n/**\n * Generates a UUID v4 options from a given Ethereum address.\n *\n * @param address - The Ethereum address to generate the UUID from.\n * @returns The UUID v4 options.\n */\nexport function getUUIDOptionsFromAddressOfNormalAccount(\n  address: string,\n): V4Options {\n  const v4options = {\n    random: sha256(hexToBytes(address)).slice(0, 16),\n  };\n\n  return v4options;\n}\n\n/**\n * Generates a UUID from a given Ethereum address.\n *\n * @param address - The Ethereum address to generate the UUID from.\n * @returns The generated UUID.\n */\nexport function getUUIDFromAddressOfNormalAccount(address: string): string {\n  return uuid(getUUIDOptionsFromAddressOfNormalAccount(address));\n}\n\n/**\n * Check if a keyring type is considered a \"normal\" keyring.\n *\n * @param keyringType - The account's keyring type.\n * @returns True if the keyring type is considered a \"normal\" keyring, false otherwise.\n */\nexport function isNormalKeyringType(\n  keyringType: KeyringTypes | string,\n): boolean {\n  // Right now, we only have to \"exclude\" Snap accounts, but this might need to be\n  // adapted later on if we have new kind of keyrings!\n  return keyringType !== (KeyringTypes.snap as string);\n}\n\n/**\n * Check if a keyring type is a Snap keyring.\n *\n * @param keyringType - The account's keyring type.\n * @returns True if the keyring type is considered a Snap keyring, false otherwise.\n */\nexport function isSnapKeyringType(keyringType: KeyringTypes | string): boolean {\n  return keyringType === (KeyringTypes.snap as string);\n}\n\n/**\n * Check if a keyring type is a simple keyring.\n *\n * @param keyringType - The account's keyring type.\n * @returns True if the keyring type is considered a simple keyring, false otherwise.\n */\nexport function isSimpleKeyringType(\n  keyringType: KeyringTypes | string,\n): boolean {\n  return keyringType === (KeyringTypes.simple as string);\n}\n\n/**\n * Check if a keyring is a HD keyring.\n *\n * @param keyringType - The account's keyring type.\n * @returns True if the keyring is a HD keyring, false otherwise.\n */\nexport function isHdKeyringType(keyringType: KeyringTypes | string): boolean {\n  return keyringType === (KeyringTypes.hd as string);\n}\n\n/**\n * Get the derivation path for the index of an account within a EVM HD keyring.\n *\n * @param index - The account index.\n * @returns The derivation path.\n */\nexport function getEvmDerivationPathForIndex(index: number): string {\n  const purpose = '44';\n  const coinType = '60'; // Ethereum.\n  return `m/${purpose}'/${coinType}'/0'/0/${index}`;\n}\n\n/**\n * Get the group index from a keyring object (EVM HD keyring only) and an address.\n *\n * @param keyring - The keyring object.\n * @param address - The address to match.\n * @returns The group index for that address, undefined if not able to match the address.\n */\nexport function getEvmGroupIndexFromAddressIndex(\n  keyring: KeyringObject,\n  address: string,\n): number | undefined {\n  // TODO: Remove this function once EVM HD keyrings start using the new unified\n  // keyring API.\n\n  // NOTE: We mostly put that logic in a separate function so we can easily add coverage\n  // for (supposedly) unreachable code path.\n\n  if (!isHdKeyringType(keyring.type)) {\n    // We cannot extract the group index from non-HD keyrings.\n    return undefined;\n  }\n\n  // We need to find the account index from its HD keyring. We assume those\n  // accounts are ordered, thus we can use their index to compute their\n  // derivation path and group index.\n  const groupIndex = keyring.accounts.findIndex(\n    // NOTE: This is ok to use `toLowerCase` here, since we're only dealing\n    // with EVM addresses.\n    (accountAddress) => accountAddress.toLowerCase() === address.toLowerCase(),\n  );\n\n  // If for some reason, we cannot find this address, then the caller made a mistake\n  // and it did not use the proper keyring object. For now, we do not fail and just\n  // consider this account as \"simple account\".\n  if (groupIndex === -1) {\n    console.warn(`! Unable to get group index for HD account: \"${address}\"`);\n    return undefined;\n  }\n\n  return groupIndex;\n}\n\n/**\n * HD keyring account for Snap accounts that handles non-EVM HD accounts. (e.g the\n * Solana Snap).\n *\n * NOTE: We use `superstruct.type` here `superstruct.object` since it allows\n * extra-properties than a Snap might add in its `options`.\n */\nexport const HdSnapKeyringAccountOptionsStruct = type({\n  entropySource: string(),\n  index: number(),\n  derivationPath: string(),\n});\nexport type HdSnapKeyringAccountOptions = Infer<\n  typeof HdSnapKeyringAccountOptionsStruct\n>;\n\n/**\n * HD keyring account for Snap accounts that handles non-EVM HD accounts.\n */\nexport type HdSnapKeyringAccount = InternalAccount & {\n  options: InternalAccount['options'] & HdSnapKeyringAccountOptions;\n};\n\n/**\n * Check if an account is an HD Snap keyring account.\n *\n * @param account - Snap keyring account.\n * @returns True if valid, false otherwise.\n */\nexport function isHdSnapKeyringAccount(\n  account: InternalAccount,\n): account is HdSnapKeyringAccount {\n  return is(account.options, HdSnapKeyringAccountOptionsStruct);\n}\n"]}