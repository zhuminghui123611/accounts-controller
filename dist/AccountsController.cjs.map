{"version":3,"file":"AccountsController.cjs","sourceRoot":"","sources":["../src/AccountsController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type ControllerGetStateAction,\n  type ControllerStateChangeEvent,\n  type ExtractEventPayload,\n  type RestrictedMessenger,\n  BaseController,\n} from '@metamask/base-controller';\nimport {\n  type SnapKeyringAccountAssetListUpdatedEvent,\n  type SnapKeyringAccountBalancesUpdatedEvent,\n  type SnapKeyringAccountTransactionsUpdatedEvent,\n  SnapKeyring,\n} from '@metamask/eth-snap-keyring';\nimport type { KeyringAccountEntropyOptions } from '@metamask/keyring-api';\nimport {\n  EthAccountType,\n  EthMethod,\n  EthScope,\n  isEvmAccountType,\n  KeyringAccountEntropyTypeOption,\n} from '@metamask/keyring-api';\nimport type { KeyringObject } from '@metamask/keyring-controller';\nimport {\n  type KeyringControllerState,\n  type KeyringControllerGetKeyringsByTypeAction,\n  type KeyringControllerStateChangeEvent,\n  type KeyringControllerGetStateAction,\n  KeyringTypes,\n} from '@metamask/keyring-controller';\nimport type { InternalAccount } from '@metamask/keyring-internal-api';\nimport { isScopeEqualToAny } from '@metamask/keyring-utils';\nimport type { NetworkClientId } from '@metamask/network-controller';\nimport type {\n  SnapControllerState,\n  SnapStateChange,\n} from '@metamask/snaps-controllers';\nimport type { SnapId } from '@metamask/snaps-sdk';\nimport { type CaipChainId, isCaipChainId } from '@metamask/utils';\nimport type { WritableDraft } from 'immer/dist/internal.js';\nimport { cloneDeep } from 'lodash';\n\nimport type { MultichainNetworkControllerNetworkDidChangeEvent } from './types';\nimport type { AccountsControllerStrictState } from './typing';\nimport type { HdSnapKeyringAccount } from './utils';\nimport {\n  getEvmDerivationPathForIndex,\n  getEvmGroupIndexFromAddressIndex,\n  getUUIDFromAddressOfNormalAccount,\n  isHdKeyringType,\n  isHdSnapKeyringAccount,\n  isSimpleKeyringType,\n  isSnapKeyringType,\n  keyringTypeToName,\n} from './utils';\n\nconst controllerName = 'AccountsController';\n\nexport type AccountId = string;\n\nexport type AccountsControllerState = {\n  internalAccounts: {\n    accounts: Record<AccountId, InternalAccount>;\n    selectedAccount: string; // id of the selected account\n  };\n};\n\nexport type AccountsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  AccountsControllerState\n>;\n\nexport type AccountsControllerSetSelectedAccountAction = {\n  type: `${typeof controllerName}:setSelectedAccount`;\n  handler: AccountsController['setSelectedAccount'];\n};\n\nexport type AccountsControllerSetAccountNameAction = {\n  type: `${typeof controllerName}:setAccountName`;\n  handler: AccountsController['setAccountName'];\n};\n\nexport type AccountsControllerSetAccountNameAndSelectAccountAction = {\n  type: `${typeof controllerName}:setAccountNameAndSelectAccount`;\n  handler: AccountsController['setAccountNameAndSelectAccount'];\n};\n\nexport type AccountsControllerListAccountsAction = {\n  type: `${typeof controllerName}:listAccounts`;\n  handler: AccountsController['listAccounts'];\n};\n\nexport type AccountsControllerListMultichainAccountsAction = {\n  type: `${typeof controllerName}:listMultichainAccounts`;\n  handler: AccountsController['listMultichainAccounts'];\n};\n\nexport type AccountsControllerUpdateAccountsAction = {\n  type: `${typeof controllerName}:updateAccounts`;\n  handler: AccountsController['updateAccounts'];\n};\n\nexport type AccountsControllerGetSelectedAccountAction = {\n  type: `${typeof controllerName}:getSelectedAccount`;\n  handler: AccountsController['getSelectedAccount'];\n};\n\nexport type AccountsControllerGetSelectedMultichainAccountAction = {\n  type: `${typeof controllerName}:getSelectedMultichainAccount`;\n  handler: AccountsController['getSelectedMultichainAccount'];\n};\n\nexport type AccountsControllerGetAccountByAddressAction = {\n  type: `${typeof controllerName}:getAccountByAddress`;\n  handler: AccountsController['getAccountByAddress'];\n};\n\nexport type AccountsControllerGetNextAvailableAccountNameAction = {\n  type: `${typeof controllerName}:getNextAvailableAccountName`;\n  handler: AccountsController['getNextAvailableAccountName'];\n};\n\nexport type AccountsControllerGetAccountAction = {\n  type: `${typeof controllerName}:getAccount`;\n  handler: AccountsController['getAccount'];\n};\n\nexport type AccountsControllerUpdateAccountMetadataAction = {\n  type: `${typeof controllerName}:updateAccountMetadata`;\n  handler: AccountsController['updateAccountMetadata'];\n};\n\nexport type AllowedActions =\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetStateAction;\n\nexport type AccountsControllerActions =\n  | AccountsControllerGetStateAction\n  | AccountsControllerSetSelectedAccountAction\n  | AccountsControllerListAccountsAction\n  | AccountsControllerListMultichainAccountsAction\n  | AccountsControllerSetAccountNameAction\n  | AccountsControllerSetAccountNameAndSelectAccountAction\n  | AccountsControllerUpdateAccountsAction\n  | AccountsControllerGetAccountByAddressAction\n  | AccountsControllerGetSelectedAccountAction\n  | AccountsControllerGetNextAvailableAccountNameAction\n  | AccountsControllerGetAccountAction\n  | AccountsControllerGetSelectedMultichainAccountAction\n  | AccountsControllerUpdateAccountMetadataAction;\n\nexport type AccountsControllerChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  AccountsControllerState\n>;\n\nexport type AccountsControllerSelectedAccountChangeEvent = {\n  type: `${typeof controllerName}:selectedAccountChange`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerSelectedEvmAccountChangeEvent = {\n  type: `${typeof controllerName}:selectedEvmAccountChange`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerAccountAddedEvent = {\n  type: `${typeof controllerName}:accountAdded`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerAccountRemovedEvent = {\n  type: `${typeof controllerName}:accountRemoved`;\n  payload: [AccountId];\n};\n\nexport type AccountsControllerAccountRenamedEvent = {\n  type: `${typeof controllerName}:accountRenamed`;\n  payload: [InternalAccount];\n};\n\nexport type AccountsControllerAccountBalancesUpdatesEvent = {\n  type: `${typeof controllerName}:accountBalancesUpdated`;\n  payload: SnapKeyringAccountBalancesUpdatedEvent['payload'];\n};\n\nexport type AccountsControllerAccountTransactionsUpdatedEvent = {\n  type: `${typeof controllerName}:accountTransactionsUpdated`;\n  payload: SnapKeyringAccountTransactionsUpdatedEvent['payload'];\n};\n\nexport type AccountsControllerAccountAssetListUpdatedEvent = {\n  type: `${typeof controllerName}:accountAssetListUpdated`;\n  payload: SnapKeyringAccountAssetListUpdatedEvent['payload'];\n};\n\nexport type AllowedEvents =\n  | SnapStateChange\n  | KeyringControllerStateChangeEvent\n  | SnapKeyringAccountAssetListUpdatedEvent\n  | SnapKeyringAccountBalancesUpdatedEvent\n  | SnapKeyringAccountTransactionsUpdatedEvent\n  | MultichainNetworkControllerNetworkDidChangeEvent;\n\nexport type AccountsControllerEvents =\n  | AccountsControllerChangeEvent\n  | AccountsControllerSelectedAccountChangeEvent\n  | AccountsControllerSelectedEvmAccountChangeEvent\n  | AccountsControllerAccountAddedEvent\n  | AccountsControllerAccountRemovedEvent\n  | AccountsControllerAccountRenamedEvent\n  | AccountsControllerAccountBalancesUpdatesEvent\n  | AccountsControllerAccountTransactionsUpdatedEvent\n  | AccountsControllerAccountAssetListUpdatedEvent;\n\nexport type AccountsControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  AccountsControllerActions | AllowedActions,\n  AccountsControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\nconst accountsControllerMetadata = {\n  internalAccounts: {\n    includeInStateLogs: true,\n    persist: true,\n    anonymous: false,\n    usedInUi: true,\n  },\n};\n\nconst defaultState: AccountsControllerState = {\n  internalAccounts: {\n    accounts: {},\n    selectedAccount: '',\n  },\n};\n\nexport const EMPTY_ACCOUNT = {\n  id: '',\n  address: '',\n  options: {},\n  methods: [],\n  type: EthAccountType.Eoa,\n  scopes: [EthScope.Eoa],\n  metadata: {\n    name: '',\n    keyring: {\n      type: '',\n    },\n    importTime: 0,\n  },\n};\n\n/**\n * Controller that manages internal accounts.\n * The accounts controller is responsible for creating and managing internal accounts.\n * It also provides convenience methods for accessing and updating the internal accounts.\n * The accounts controller also listens for keyring state changes and updates the internal accounts accordingly.\n * The accounts controller also listens for snap state changes and updates the internal accounts accordingly.\n *\n */\nexport class AccountsController extends BaseController<\n  typeof controllerName,\n  AccountsControllerState,\n  AccountsControllerMessenger\n> {\n  /**\n   * Constructor for AccountsController.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The messenger object.\n   * @param options.state - Initial state to set on this controller\n   */\n  constructor({\n    messenger,\n    state,\n  }: {\n    messenger: AccountsControllerMessenger;\n    state: AccountsControllerState;\n  }) {\n    super({\n      messenger,\n      name: controllerName,\n      metadata: accountsControllerMetadata,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#subscribeToMessageEvents();\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Returns the internal account object for the given account ID, if it exists.\n   *\n   * @param accountId - The ID of the account to retrieve.\n   * @returns The internal account object, or undefined if the account does not exist.\n   */\n  getAccount(accountId: string): InternalAccount | undefined {\n    return this.state.internalAccounts.accounts[accountId];\n  }\n\n  /**\n   * Returns an array of all evm internal accounts.\n   *\n   * @returns An array of InternalAccount objects.\n   */\n  listAccounts(): InternalAccount[] {\n    const accounts = Object.values(this.state.internalAccounts.accounts);\n    return accounts.filter((account) => isEvmAccountType(account.type));\n  }\n\n  /**\n   * Returns an array of all internal accounts.\n   *\n   * @param chainId - The chain ID.\n   * @returns An array of InternalAccount objects.\n   */\n  listMultichainAccounts(chainId?: CaipChainId): InternalAccount[] {\n    const accounts = Object.values(this.state.internalAccounts.accounts);\n    if (!chainId) {\n      return accounts;\n    }\n\n    if (!isCaipChainId(chainId)) {\n      throw new Error(`Invalid CAIP-2 chain ID: ${String(chainId)}`);\n    }\n\n    return accounts.filter((account) =>\n      isScopeEqualToAny(chainId, account.scopes),\n    );\n  }\n\n  /**\n   * Returns the internal account object for the given account ID.\n   *\n   * @param accountId - The ID of the account to retrieve.\n   * @returns The internal account object.\n   * @throws An error if the account ID is not found.\n   */\n  getAccountExpect(accountId: string): InternalAccount {\n    const account = this.getAccount(accountId);\n    if (account === undefined) {\n      throw new Error(`Account Id \"${accountId}\" not found`);\n    }\n    return account;\n  }\n\n  /**\n   * Returns the last selected EVM account.\n   *\n   * @returns The selected internal account.\n   */\n  getSelectedAccount(): InternalAccount {\n    const {\n      internalAccounts: { selectedAccount },\n    } = this.state;\n\n    // Edge case where the extension is setup but the srp is not yet created\n    // certain ui elements will query the selected address before any accounts are created.\n    if (selectedAccount === '') {\n      return EMPTY_ACCOUNT;\n    }\n\n    const account = this.getAccountExpect(selectedAccount);\n    if (isEvmAccountType(account.type)) {\n      return account;\n    }\n\n    const accounts = this.listAccounts();\n    if (!accounts.length) {\n      // ! Should never reach this.\n      throw new Error('No EVM accounts');\n    }\n\n    // This will never be undefined because we have already checked if accounts.length is > 0\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#getLastSelectedAccount(accounts)!;\n  }\n\n  /**\n   * __WARNING The return value may be undefined if there isn't an account for that chain id.__\n   *\n   * Retrieves the last selected account by chain ID.\n   *\n   * @param chainId - The chain ID to filter the accounts.\n   * @returns The last selected account compatible with the specified chain ID or undefined.\n   */\n  getSelectedMultichainAccount(\n    chainId?: CaipChainId,\n  ): InternalAccount | undefined {\n    const {\n      internalAccounts: { selectedAccount },\n    } = this.state;\n\n    // Edge case where the extension is setup but the srp is not yet created\n    // certain ui elements will query the selected address before any accounts are created.\n    if (selectedAccount === '') {\n      return EMPTY_ACCOUNT;\n    }\n\n    if (!chainId) {\n      return this.getAccountExpect(selectedAccount);\n    }\n\n    const accounts = this.listMultichainAccounts(chainId);\n    return this.#getLastSelectedAccount(accounts);\n  }\n\n  /**\n   * Returns the account with the specified address.\n   * ! This method will only return the first account that matches the address\n   *\n   * @param address - The address of the account to retrieve.\n   * @returns The account with the specified address, or undefined if not found.\n   */\n  getAccountByAddress(address: string): InternalAccount | undefined {\n    return this.listMultichainAccounts().find(\n      (account) => account.address.toLowerCase() === address.toLowerCase(),\n    );\n  }\n\n  /**\n   * Sets the selected account by its ID.\n   *\n   * @param accountId - The ID of the account to be selected.\n   */\n  setSelectedAccount(accountId: string): void {\n    const account = this.getAccountExpect(accountId);\n\n    if (this.state.internalAccounts.selectedAccount === account.id) {\n      return;\n    }\n\n    this.#update((state) => {\n      const { internalAccounts } = state;\n\n      internalAccounts.accounts[account.id].metadata.lastSelected = Date.now();\n      internalAccounts.selectedAccount = account.id;\n    });\n  }\n\n  /**\n   * Sets the name of the account with the given ID.\n   *\n   * @param accountId - The ID of the account to set the name for.\n   * @param accountName - The new name for the account.\n   * @throws An error if an account with the same name already exists.\n   */\n  setAccountName(accountId: string, accountName: string): void {\n    // This will check for name uniqueness and fire the `accountRenamed` event\n    // if the account has been renamed.\n    this.updateAccountMetadata(accountId, {\n      name: accountName,\n      nameLastUpdatedAt: Date.now(),\n    });\n  }\n\n  /**\n   * Sets the name of the account with the given ID and select it.\n   *\n   * @param accountId - The ID of the account to set the name for and select.\n   * @param accountName - The new name for the account.\n   * @throws An error if an account with the same name already exists.\n   */\n  setAccountNameAndSelectAccount(accountId: string, accountName: string): void {\n    const account = this.getAccountExpect(accountId);\n\n    this.#assertAccountCanBeRenamed(account, accountName);\n\n    const internalAccount = {\n      ...account,\n      metadata: {\n        ...account.metadata,\n        name: accountName,\n        nameLastUpdatedAt: Date.now(),\n        lastSelected: this.#getLastSelectedIndex(),\n      },\n    };\n\n    this.#update((state) => {\n      state.internalAccounts.accounts[account.id] = internalAccount;\n      state.internalAccounts.selectedAccount = account.id;\n    });\n\n    this.messagingSystem.publish(\n      'AccountsController:accountRenamed',\n      internalAccount,\n    );\n  }\n\n  #assertAccountCanBeRenamed(account: InternalAccount, accountName: string) {\n    if (\n      this.listMultichainAccounts().find(\n        (internalAccount) =>\n          internalAccount.metadata.name === accountName &&\n          internalAccount.id !== account.id,\n      )\n    ) {\n      throw new Error('Account name already exists');\n    }\n  }\n\n  /**\n   * Updates the metadata of the account with the given ID.\n   *\n   * @param accountId - The ID of the account for which the metadata will be updated.\n   * @param metadata - The new metadata for the account.\n   */\n  updateAccountMetadata(\n    accountId: string,\n    metadata: Partial<InternalAccount['metadata']>,\n  ): void {\n    const account = this.getAccountExpect(accountId);\n\n    if (metadata.name) {\n      this.#assertAccountCanBeRenamed(account, metadata.name);\n    }\n\n    const internalAccount = {\n      ...account,\n      metadata: { ...account.metadata, ...metadata },\n    };\n\n    this.#update((state) => {\n      state.internalAccounts.accounts[accountId] = internalAccount;\n    });\n\n    if (metadata.name) {\n      this.messagingSystem.publish(\n        'AccountsController:accountRenamed',\n        internalAccount,\n      );\n    }\n  }\n\n  /**\n   * Updates the internal accounts list by retrieving normal and snap accounts,\n   * removing duplicates, and updating the metadata of each account.\n   *\n   * @returns A Promise that resolves when the accounts have been updated.\n   */\n  async updateAccounts(): Promise<void> {\n    const keyringAccountIndexes = new Map<string, number>();\n\n    const existingInternalAccounts = this.state.internalAccounts.accounts;\n    const internalAccounts: AccountsControllerState['internalAccounts']['accounts'] =\n      {};\n\n    const { keyrings } = this.messagingSystem.call(\n      'KeyringController:getState',\n    );\n    for (const keyring of keyrings) {\n      const keyringTypeName = keyringTypeToName(keyring.type);\n\n      for (const address of keyring.accounts) {\n        const internalAccount = this.#getInternalAccountFromAddressAndType(\n          address,\n          keyring,\n        );\n\n        // This should never really happen, but if for some reason we're not\n        // able to get the Snap keyring reference, this would return an\n        // undefined account.\n        // So we just skip it, even though, this should not really happen.\n        if (!internalAccount) {\n          continue;\n        }\n\n        // Get current index for this keyring (we use human indexing, so start at 1).\n        const keyringAccountIndex =\n          keyringAccountIndexes.get(keyringTypeName) ?? 1;\n\n        const existingAccount = existingInternalAccounts[internalAccount.id];\n        internalAccounts[internalAccount.id] = {\n          ...internalAccount,\n\n          metadata: {\n            ...internalAccount.metadata,\n\n            // Re-use existing metadata if any.\n            name:\n              existingAccount?.metadata.name ??\n              `${keyringTypeName} ${keyringAccountIndex}`,\n            importTime: existingAccount?.metadata.importTime ?? Date.now(),\n            lastSelected: existingAccount?.metadata.lastSelected ?? 0,\n          },\n        };\n\n        // Increment the account index for this keyring.\n        keyringAccountIndexes.set(keyringTypeName, keyringAccountIndex + 1);\n      }\n    }\n\n    this.#update((state) => {\n      state.internalAccounts.accounts = internalAccounts;\n    });\n  }\n\n  /**\n   * Loads the backup state of the accounts controller.\n   *\n   * @param backup - The backup state to load.\n   */\n  loadBackup(backup: AccountsControllerState): void {\n    if (backup.internalAccounts) {\n      this.update(\n        (currentState: WritableDraft<AccountsControllerStrictState>) => {\n          currentState.internalAccounts = backup.internalAccounts;\n        },\n      );\n    }\n  }\n\n  /**\n   * Gets an internal account representation for a non-Snap account.\n   *\n   * @param address - The address of the account.\n   * @param keyring - The keyring object of the account.\n   * @returns The generated internal account.\n   */\n  #getInternalAccountForNonSnapAccount(\n    address: string,\n    keyring: KeyringObject,\n  ): InternalAccount {\n    const id = getUUIDFromAddressOfNormalAccount(address);\n\n    // We might have an account for this ID already, so we'll just re-use\n    // the same metadata\n    const account = this.getAccount(id);\n    const metadata: InternalAccount['metadata'] = {\n      name: account?.metadata.name ?? '',\n      ...(account?.metadata.nameLastUpdatedAt\n        ? {\n            nameLastUpdatedAt: account?.metadata.nameLastUpdatedAt,\n          }\n        : {}),\n      importTime: account?.metadata.importTime ?? Date.now(),\n      lastSelected: account?.metadata.lastSelected ?? 0,\n      keyring: {\n        type: keyring.type,\n      },\n    };\n\n    let options: InternalAccount['options'] = {};\n    if (isHdKeyringType(keyring.type)) {\n      // We need to find the account index from its HD keyring.\n      const groupIndex = getEvmGroupIndexFromAddressIndex(keyring, address);\n\n      // If for some reason, we cannot find this address, then the caller made a mistake\n      // and it did not use the proper keyring object. For now, we do not fail and just\n      // consider this account as \"simple account\".\n      if (groupIndex !== undefined) {\n        // NOTE: We are not using the `hdPath` from the associated keyring here and\n        // getting the keyring instance here feels a bit overkill.\n        // This will be naturally fixed once every keyring start using `KeyringAccount` and implement the keyring API.\n        const derivationPath = getEvmDerivationPathForIndex(groupIndex);\n\n        // Those are \"legacy options\" and they were used before `KeyringAccount` added\n        // support for type options. We keep those temporarily until we update everything\n        // to use the new typed options.\n        const legacyOptions = {\n          entropySource: keyring.metadata.id,\n          derivationPath,\n          groupIndex,\n        };\n\n        // New typed entropy options. This is required for multichain accounts.\n        const entropyOptions: { entropy: KeyringAccountEntropyOptions } = {\n          entropy: {\n            type: KeyringAccountEntropyTypeOption.Mnemonic,\n            id: keyring.metadata.id,\n            derivationPath,\n            groupIndex,\n          },\n        };\n\n        options = {\n          ...legacyOptions,\n          ...entropyOptions,\n        };\n      }\n    }\n\n    return {\n      id,\n      address,\n      options,\n      methods: [\n        EthMethod.PersonalSign,\n        EthMethod.Sign,\n        EthMethod.SignTransaction,\n        EthMethod.SignTypedDataV1,\n        EthMethod.SignTypedDataV3,\n        EthMethod.SignTypedDataV4,\n      ],\n      scopes: [EthScope.Eoa],\n      type: EthAccountType.Eoa,\n      metadata,\n    };\n  }\n\n  /**\n   * Get Snap keyring from the keyring controller.\n   *\n   * @returns The Snap keyring if available.\n   */\n  #getSnapKeyring(): SnapKeyring | undefined {\n    const [snapKeyring] = this.messagingSystem.call(\n      'KeyringController:getKeyringsByType',\n      SnapKeyring.type,\n    );\n\n    // Snap keyring is not available until the first account is created in the keyring\n    // controller, so this might be undefined.\n    return snapKeyring as SnapKeyring | undefined;\n  }\n\n  /**\n   * Re-publish an account event.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @param payload - The event payload. The type of the parameters for each event handler must\n   * match the type of this payload.\n   * @template EventType - A Snap keyring event type.\n   */\n  #handleOnSnapKeyringAccountEvent<\n    EventType extends AccountsControllerEvents['type'],\n  >(\n    event: EventType,\n    ...payload: ExtractEventPayload<AccountsControllerEvents, EventType>\n  ): void {\n    this.messagingSystem.publish(event, ...payload);\n  }\n\n  /**\n   * Handles changes in the keyring state, specifically when new accounts are added or removed.\n   *\n   * @param keyringState - The new state of the keyring controller.\n   * @param keyringState.isUnlocked - True if the keyrings are unlocked, false otherwise.\n   * @param keyringState.keyrings - List of all keyrings.\n   */\n  #handleOnKeyringStateChange({\n    isUnlocked,\n    keyrings,\n  }: KeyringControllerState): void {\n    // TODO: Change when accountAdded event is added to the keyring controller.\n\n    // We check for keyrings length to be greater than 0 because the extension client may try execute\n    // submit password twice and clear the keyring state.\n    // https://github.com/MetaMask/KeyringController/blob/2d73a4deed8d013913f6ef0c9f5c0bb7c614f7d3/src/KeyringController.ts#L910\n    if (!isUnlocked || keyrings.length === 0) {\n      return;\n    }\n\n    // State patches.\n    const generatePatch = () => {\n      return {\n        previous: {} as Record<string, InternalAccount>,\n        added: [] as {\n          address: string;\n          keyring: KeyringObject;\n        }[],\n        updated: [] as InternalAccount[],\n        removed: [] as InternalAccount[],\n      };\n    };\n    const patches = {\n      snap: generatePatch(),\n      normal: generatePatch(),\n    };\n\n    // Gets the patch object based on the keyring type (since Snap accounts and other accounts\n    // are handled differently).\n    const patchOf = (type: string) => {\n      if (isSnapKeyringType(type)) {\n        return patches.snap;\n      }\n      return patches.normal;\n    };\n\n    // Create a map (with lower-cased addresses) of all existing accounts.\n    for (const account of this.listMultichainAccounts()) {\n      const address = account.address.toLowerCase();\n      const patch = patchOf(account.metadata.keyring.type);\n\n      patch.previous[address] = account;\n    }\n\n    // Go over all keyring changes and create patches out of it.\n    const addresses = new Set<string>();\n    for (const keyring of keyrings) {\n      const patch = patchOf(keyring.type);\n\n      for (const accountAddress of keyring.accounts) {\n        // Lower-case address to use it in the `previous` map.\n        const address = accountAddress.toLowerCase();\n        const account = patch.previous[address];\n\n        if (account) {\n          // If the account exists before, this might be an update.\n          patch.updated.push(account);\n        } else {\n          // Otherwise, that's a new account.\n          patch.added.push({\n            address,\n            keyring,\n          });\n        }\n\n        // Keep track of those address to check for removed accounts later.\n        addresses.add(address);\n      }\n    }\n\n    // We might have accounts associated with removed keyrings, so we iterate\n    // over all previous known accounts and check against the keyring addresses.\n    for (const patch of [patches.snap, patches.normal]) {\n      for (const [address, account] of Object.entries(patch.previous)) {\n        // If a previous address is not part of the new addesses, then it got removed.\n        if (!addresses.has(address)) {\n          patch.removed.push(account);\n        }\n      }\n    }\n\n    // Diff that we will use to publish events afterward.\n    const diff = {\n      removed: [] as string[],\n      added: [] as InternalAccount[],\n    };\n\n    this.#update(\n      (state) => {\n        const { internalAccounts } = state;\n\n        for (const patch of [patches.snap, patches.normal]) {\n          for (const account of patch.removed) {\n            delete internalAccounts.accounts[account.id];\n\n            diff.removed.push(account.id);\n          }\n\n          for (const added of patch.added) {\n            const account = this.#getInternalAccountFromAddressAndType(\n              added.address,\n              added.keyring,\n            );\n\n            if (account) {\n              // Re-compute the list of accounts everytime, so we can make sure new names\n              // are also considered.\n              const accounts = Object.values(\n                internalAccounts.accounts,\n              ) as InternalAccount[];\n\n              // Get next account name available for this given keyring.\n              const name = this.getNextAvailableAccountName(\n                account.metadata.keyring.type,\n                accounts,\n              );\n\n              // If it's the first account, we need to select it.\n              const lastSelected =\n                accounts.length === 0 ? this.#getLastSelectedIndex() : 0;\n\n              internalAccounts.accounts[account.id] = {\n                ...account,\n                metadata: {\n                  ...account.metadata,\n                  name,\n                  importTime: Date.now(),\n                  lastSelected,\n                },\n              };\n\n              diff.added.push(internalAccounts.accounts[account.id]);\n            }\n          }\n        }\n      },\n      // Will get executed after the update, but before re-selecting an account in case\n      // the current one is not valid anymore.\n      () => {\n        // Now publish events\n        for (const id of diff.removed) {\n          this.messagingSystem.publish('AccountsController:accountRemoved', id);\n        }\n\n        for (const account of diff.added) {\n          this.messagingSystem.publish(\n            'AccountsController:accountAdded',\n            account,\n          );\n        }\n      },\n    );\n\n    // NOTE: Since we also track \"updated\" accounts with our patches, we could fire a new event\n    // like `accountUpdated` (we would still need to check if anything really changed on the account).\n  }\n\n  /**\n   * Update the state and fixup the currently selected account.\n   *\n   * @param callback - Callback for updating state, passed a draft state object.\n   * @param beforeAutoSelectAccount - Callback to be executed before auto-selecting an account\n   * if the current one is no longer available.\n   */\n  #update(\n    callback: (state: WritableDraft<AccountsControllerStrictState>) => void,\n    beforeAutoSelectAccount?: () => void,\n  ) {\n    // The currently selected account might get deleted during the update, so keep track\n    // of it before doing any change.\n    const previouslySelectedAccount =\n      this.state.internalAccounts.selectedAccount;\n\n    this.update((state: WritableDraft<AccountsControllerStrictState>) => {\n      callback(state);\n\n      // If the account no longer exists (or none is selected), we need to re-select another one.\n      const { internalAccounts } = state;\n      if (!internalAccounts.accounts[previouslySelectedAccount]) {\n        const accounts = Object.values(\n          internalAccounts.accounts,\n        ) as InternalAccount[];\n\n        // Get the lastly selected account (according to the current accounts).\n        const lastSelectedAccount = this.#getLastSelectedAccount(accounts);\n        if (lastSelectedAccount) {\n          internalAccounts.selectedAccount = lastSelectedAccount.id;\n          internalAccounts.accounts[\n            lastSelectedAccount.id\n          ].metadata.lastSelected = this.#getLastSelectedIndex();\n        } else {\n          // It will be undefined if there are no accounts.\n          internalAccounts.selectedAccount = '';\n        }\n      }\n    });\n\n    // We might want to do some pre-work before selecting a new account.\n    beforeAutoSelectAccount?.();\n\n    // Now, we compare the newly selected account, and we send event if different.\n    const { selectedAccount } = this.state.internalAccounts;\n    if (selectedAccount && selectedAccount !== previouslySelectedAccount) {\n      const account = this.getSelectedMultichainAccount();\n\n      // The account should always be defined at this point, since we have already checked for\n      // `selectedAccount` to be non-empty.\n      if (account) {\n        if (isEvmAccountType(account.type)) {\n          this.messagingSystem.publish(\n            'AccountsController:selectedEvmAccountChange',\n            account,\n          );\n        }\n        this.messagingSystem.publish(\n          'AccountsController:selectedAccountChange',\n          account,\n        );\n      }\n    }\n  }\n\n  /**\n   * Handles the change in SnapControllerState by updating the metadata of accounts that have a snap enabled.\n   *\n   * @param snapState - The new SnapControllerState.\n   */\n  #handleOnSnapStateChange(snapState: SnapControllerState) {\n    // Only check if Snaps changed in status.\n    const { snaps } = snapState;\n\n    const accounts: { id: string; enabled: boolean }[] = [];\n    for (const account of this.listMultichainAccounts()) {\n      if (account.metadata.snap) {\n        const snap = snaps[account.metadata.snap.id as SnapId];\n\n        if (snap) {\n          const enabled = snap.enabled && !snap.blocked;\n          const metadata = account.metadata.snap;\n\n          if (metadata.enabled !== enabled) {\n            accounts.push({ id: account.id, enabled });\n          }\n        } else {\n          // If Snap could not be found on the state, we consider it disabled.\n          accounts.push({ id: account.id, enabled: false });\n        }\n      }\n    }\n\n    if (accounts.length > 0) {\n      this.update((state) => {\n        for (const { id, enabled } of accounts) {\n          const account = state.internalAccounts.accounts[id];\n\n          if (account.metadata.snap) {\n            account.metadata.snap.enabled = enabled;\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the list of accounts for a given keyring type.\n   *\n   * @param keyringType - The type of keyring.\n   * @param accounts - Accounts to filter by keyring type.\n   * @returns The list of accounts associcated with this keyring type.\n   */\n  #getAccountsByKeyringType(keyringType: string, accounts?: InternalAccount[]) {\n    return (accounts ?? this.listMultichainAccounts()).filter(\n      (internalAccount) => {\n        // We do consider `hd` and `simple` keyrings to be of same type. So we check those 2 types\n        // to group those accounts together!\n        if (isHdKeyringType(keyringType) || isSimpleKeyringType(keyringType)) {\n          return (\n            isHdKeyringType(internalAccount.metadata.keyring.type) ||\n            isSimpleKeyringType(internalAccount.metadata.keyring.type)\n          );\n        }\n\n        return internalAccount.metadata.keyring.type === keyringType;\n      },\n    );\n  }\n\n  /**\n   * Returns the last selected account from the given array of accounts.\n   *\n   * @param accounts - An array of InternalAccount objects.\n   * @returns The InternalAccount object that was last selected, or undefined if the array is empty.\n   */\n  #getLastSelectedAccount(\n    accounts: InternalAccount[],\n  ): InternalAccount | undefined {\n    const [accountToSelect] = accounts.sort((accountA, accountB) => {\n      // sort by lastSelected descending\n      return (\n        (accountB.metadata.lastSelected ?? 0) -\n        (accountA.metadata.lastSelected ?? 0)\n      );\n    });\n\n    return accountToSelect;\n  }\n\n  /**\n   * Returns the next account number for a given keyring type.\n   *\n   * @param keyringType - The type of keyring.\n   * @param accounts - Existing accounts to check for the next available account number.\n   * @returns An object containing the account prefix and index to use.\n   */\n  getNextAvailableAccountName(\n    keyringType: string = KeyringTypes.hd,\n    accounts?: InternalAccount[],\n  ): string {\n    const keyringName = keyringTypeToName(keyringType);\n    const keyringAccounts = this.#getAccountsByKeyringType(\n      keyringType,\n      accounts,\n    );\n    const lastDefaultIndexUsedForKeyringType = keyringAccounts.reduce(\n      (maxInternalAccountIndex, internalAccount) => {\n        // We **DO NOT USE** `\\d+` here to only consider valid \"human\"\n        // number (rounded decimal number)\n        const match = new RegExp(`${keyringName} ([0-9]+)$`, 'u').exec(\n          internalAccount.metadata.name,\n        );\n\n        if (match) {\n          // Quoting `RegExp.exec` documentation:\n          // > The returned array has the matched text as the first item, and then one item for\n          // > each capturing group of the matched text.\n          // So use `match[1]` to get the captured value\n          const internalAccountIndex = parseInt(match[1], 10);\n          return Math.max(maxInternalAccountIndex, internalAccountIndex);\n        }\n\n        return maxInternalAccountIndex;\n      },\n      0,\n    );\n\n    const index = Math.max(\n      keyringAccounts.length + 1,\n      lastDefaultIndexUsedForKeyringType + 1,\n    );\n\n    return `${keyringName} ${index}`;\n  }\n\n  /**\n   * Retrieves the index value for `metadata.lastSelected`.\n   *\n   * @returns The index value.\n   */\n  #getLastSelectedIndex() {\n    // NOTE: For now we use the current date, since we know this value\n    // will always be higher than any already selected account index.\n    return Date.now();\n  }\n\n  /**\n   * Get an internal account given an address and a keyring type.\n   *\n   * If the account is not a Snap Keyring account, generates an internal account for it and adds it to the controller.\n   * If the account is a Snap Keyring account, retrieves the account from the keyring and adds it to the controller.\n   *\n   * @param address - The address of the new account.\n   * @param keyring - The keyring object of that new account.\n   * @returns The newly generated/retrieved internal account.\n   */\n  #getInternalAccountFromAddressAndType(\n    address: string,\n    keyring: KeyringObject,\n  ): InternalAccount | undefined {\n    if (isSnapKeyringType(keyring.type)) {\n      const snapKeyring = this.#getSnapKeyring();\n\n      // We need the Snap keyring to retrieve the account from its address.\n      if (!snapKeyring) {\n        return undefined;\n      }\n\n      // This might be undefined if the Snap deleted the account before\n      // reaching that point.\n      let account = snapKeyring.getAccountByAddress(address);\n      if (account) {\n        // We force the copy here, to avoid mutating the reference returned by the Snap keyring.\n        account = cloneDeep(account);\n\n        // MIGRATION: To avoid any existing Snap account migration, we are\n        // just \"adding\" the new typed options that we need for multichain\n        // accounts. Ultimately, we would need a real Snap account migrations\n        // (being handled by each Snaps).\n        if (isHdSnapKeyringAccount(account)) {\n          const options: HdSnapKeyringAccount['options'] = {\n            ...account.options,\n            entropy: {\n              type: KeyringAccountEntropyTypeOption.Mnemonic,\n              id: account.options.entropySource,\n              groupIndex: account.options.index,\n              derivationPath: account.options.derivationPath,\n            },\n          };\n          // Inject the new typed options to the internal account copy.\n          account.options = options;\n        }\n      }\n\n      return account;\n    }\n\n    return this.#getInternalAccountForNonSnapAccount(address, keyring);\n  }\n\n  /**\n   * Handles the change in multichain network by updating the selected account.\n   *\n   * @param id - The EVM client ID or non-EVM chain ID that changed.\n   */\n  #handleOnMultichainNetworkDidChange(id: NetworkClientId | CaipChainId) {\n    let accountId: string;\n\n    // We only support non-EVM Caip chain IDs at the moment. Ex Solana and Bitcoin\n    // MultichainNetworkController will handle throwing an error if the Caip chain ID is not supported\n    if (isCaipChainId(id)) {\n      // Update selected account to non evm account\n      const lastSelectedNonEvmAccount = this.getSelectedMultichainAccount(id);\n      // @ts-expect-error - This should never be undefined, otherwise it's a bug that should be handled\n      accountId = lastSelectedNonEvmAccount.id;\n    } else {\n      // Update selected account to evm account\n      const lastSelectedEvmAccount = this.getSelectedAccount();\n      accountId = lastSelectedEvmAccount.id;\n    }\n\n    if (this.state.internalAccounts.selectedAccount === accountId) {\n      return;\n    }\n\n    this.update((currentState) => {\n      currentState.internalAccounts.accounts[accountId].metadata.lastSelected =\n        Date.now();\n      currentState.internalAccounts.selectedAccount = accountId;\n    });\n\n    // DO NOT publish AccountsController:setSelectedAccount to prevent circular listener loops\n  }\n\n  /**\n   * Subscribes to message events.\n   */\n  #subscribeToMessageEvents() {\n    this.messagingSystem.subscribe(\n      'SnapController:stateChange',\n      (snapStateState) => this.#handleOnSnapStateChange(snapStateState),\n    );\n\n    this.messagingSystem.subscribe(\n      'KeyringController:stateChange',\n      (keyringState) => this.#handleOnKeyringStateChange(keyringState),\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapKeyring:accountAssetListUpdated',\n      (snapAccountEvent) =>\n        this.#handleOnSnapKeyringAccountEvent(\n          'AccountsController:accountAssetListUpdated',\n          snapAccountEvent,\n        ),\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapKeyring:accountBalancesUpdated',\n      (snapAccountEvent) =>\n        this.#handleOnSnapKeyringAccountEvent(\n          'AccountsController:accountBalancesUpdated',\n          snapAccountEvent,\n        ),\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapKeyring:accountTransactionsUpdated',\n      (snapAccountEvent) =>\n        this.#handleOnSnapKeyringAccountEvent(\n          'AccountsController:accountTransactionsUpdated',\n          snapAccountEvent,\n        ),\n    );\n\n    // Handle account change when multichain network is changed\n    this.messagingSystem.subscribe(\n      'MultichainNetworkController:networkDidChange',\n      (id) => this.#handleOnMultichainNetworkDidChange(id),\n    );\n  }\n\n  /**\n   * Registers message handlers for the AccountsController.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setSelectedAccount`,\n      this.setSelectedAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:listAccounts`,\n      this.listAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:listMultichainAccounts`,\n      this.listMultichainAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setAccountName`,\n      this.setAccountName.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setAccountNameAndSelectAccount`,\n      this.setAccountNameAndSelectAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateAccounts`,\n      this.updateAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSelectedAccount`,\n      this.getSelectedAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSelectedMultichainAccount`,\n      this.getSelectedMultichainAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAccountByAddress`,\n      this.getAccountByAddress.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getNextAvailableAccountName`,\n      this.getNextAvailableAccountName.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `AccountsController:getAccount`,\n      this.getAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `AccountsController:updateAccountMetadata`,\n      this.updateAccountMetadata.bind(this),\n    );\n  }\n}\n"]}